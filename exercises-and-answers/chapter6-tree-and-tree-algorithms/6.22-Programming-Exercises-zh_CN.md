1.	扩展buildParseTree函数以处理在每个字符之间没有空格的数学表达式。

2.	修改buildParseTree并评估函数以处理布尔语句（and，or，not）。记住，“not”是一个一元运算符，所以这会使你的代码有些复杂。

3.	使用findSuccessor方法，为二叉搜索树写入非递归的inorder遍历。

4.	修改二叉搜索树的代码以使其成为线程。为线程二叉搜索树编写非递归的inorder遍历方法。线程二叉树维护从每个节点到其后继的引用。

5.	修改我们的二叉搜索树的实现，以便它正确处理重复键。也就是说，如果密钥已经在树中，则新的有效载荷应当替换旧的而不是用相同的密钥添加另一个节点。

6.	创建具有有限堆大小的二进制堆。换句话说，堆只记录n个最重要的项目。如果堆的大小增长到大于n个项，则最不重要的项将被删除。

7.	清除printexp函数，使其不包括每个数字周围的一个“额外”的括号集。

8.	使用buildHeap方法，编写一个排序函数，可以对**_O_（nlogn）**时间中的列表排序。

9.	编写一个函数，它接受数学表达式的分析树，并计算表达式相对于某个变量的导数。

10.	实现二进制堆作为最大堆。

11.	使用BinaryHeap类，实现一个名为PriorityQueue的新类。您的PriorityQueue类应实现构造函数，加上入队和出队方法。
